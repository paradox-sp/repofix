name: EthSign to SideStore Converter

on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight UTC
  workflow_dispatch:

jobs:
  convert-repo:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install requests pytz packaging

      - name: Convert to SideStore format
        run: |
          python <<EOF
          import requests
          import json
          from datetime import datetime, timezone
          from collections import defaultdict
          from packaging.version import Version, InvalidVersion
          import math

          # Configuration
          SOURCE_URL = "https://repo.ethsign.fyi/"
          REPO_IDENTIFIER = "fyi.ethsign.repo"
          DEFAULT_ICON = "https://paradoxtime.tk/img/pdt_logo_nobg_shadow.png"
          MAX_VERSIONS_PER_APP = 3  # Keep 3 newest versions per app
          YOUR_REPO_URL = "https://raw.githubusercontent.com/paradox-sp/repofix/main/sidestore-source.json"

          # Fetch source
          print("🔄 Fetching EthSign repo...")
          try:
              response = requests.get(SOURCE_URL, timeout=15)
              response.raise_for_status()
              src_data = response.json()
          except Exception as e:
              print(f"❌ Error fetching source: {e}")
              exit(1)

          # Transform to SideStore format
          output = {
              "name": ""ParadoxTime Repo | Ethmod",
              "identifier": REPO_IDENTIFIER,
              "sourceURL": YOUR_REPO_URL,
              "iconURL": DEFAULT_ICON,
              "userinfo": {},
              "subtitle": "From EthSign repo, fixed for AltStore/SideStore",
              "description": "ParadoxTime Repo — fetches IPAs from EthSign repo and fixes json format for altstore.",
              "apps": []
          }

          # Group apps by bundleIdentifier
          apps_by_bundle = defaultdict(list)
          for app in src_data.get("apps", []):
              if not all(k in app for k in ["name", "bundleIdentifier", "version", "downloadURL"]):
                  continue
              apps_by_bundle[app["bundleIdentifier"]].append(app)

          def parse_version(ver_str):
              try:
                  return Version(ver_str)
              except InvalidVersion:
                  return Version("0.0.0")

          # Process each bundle
          for bundle_id, versions in apps_by_bundle.items():
              # Sort versions by version number (newest first)
              versions.sort(key=lambda x: parse_version(x.get("version", "0.0.0")), reverse=True)
              kept_versions = versions[:MAX_VERSIONS_PER_APP]

              if not kept_versions:
                  continue

              latest_version = kept_versions[0]
              now = datetime.now(timezone.utc).astimezone().isoformat()

              # Build version entries
              altstore_versions = []
              for v in kept_versions:
                  altstore_versions.append({
                      "version": v["version"],
                      "date": v.get("versionDate", now),
                      "downloadURL": v["downloadURL"],
                      "size": v.get("size", 0),
                      "absoluteVersion": v["version"],
                      "localizedDescription": v.get("localizedDescription", "Latest version")
                  })

              # Build app entry
              app_entry = {
                  "name": latest_version["name"],
                  "bundleIdentifier": bundle_id,
                  "developerName": latest_version.get("developerName", "Unknown Developer"),
                  "version": latest_version["version"],
                  "versionDate": altstore_versions[0]["date"],
                  "downloadURL": latest_version["downloadURL"],
                  "localizedDescription": latest_version.get("localizedDescription", "App from EthSign repository"),
                  "iconURL": latest_version.get("iconURL", DEFAULT_ICON),
                  "size": latest_version.get("size", 0),
                  "absoluteVersion": latest_version["version"],
                  "appID": bundle_id,
                  "versions": altstore_versions
              }

              # Add optional fields
              for field in ["subtitle", "tintColor", "screenshotURLs"]:
                  if field in latest_version:
                      app_entry[field] = latest_version[field]

              output["apps"].append(app_entry)

          # Save output
          with open("sidestore-source.json", "w") as f:
              json.dump(output, f, indent=2, ensure_ascii=False)
          print(f"✅ Generated {len(output['apps'])} apps with {MAX_VERSIONS_PER_APP} versions each")
          EOF

      - name: Validate JSON
        run: |
          sudo apt-get install -y jq
          
          # Check for duplicate bundle identifiers
          DUPLICATES=$(jq -r '.apps[].bundleIdentifier' sidestore-source.json | sort | uniq -d)
          if [ -n "$DUPLICATES" ]; then
            echo "❌ Found duplicate bundle identifiers:"
            echo "$DUPLICATES"
            exit 1
          fi

          # Check version counts
          VERSION_COUNTS=$(jq '.apps[] | .bundleIdentifier + ": " + (.versions | length | tostring)' sidestore-source.json)
          echo "ℹ️ Version counts per app:"
          echo "$VERSION_COUNTS"

          # Basic JSON validation
          if ! jq empty sidestore-source.json; then
            echo "❌ Invalid JSON structure"
            exit 1
          fi

          echo "✅ All validations passed"

      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add sidestore-source.json
          git diff --quiet && git diff --staged --quiet || git commit -m "Auto-update: $(date +'%Y-%m-%d %H:%M')"
          git push
